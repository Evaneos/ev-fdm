{"version":3,"sources":["directives/tinymceDirective.js"],"names":[],"mappings":"CASA,SAAA,GACA,GAAA,IACA,SAAA,EACA,WAAA,EACA,QAAA,EACA,QAAA,qEACA,MAAA,EACA,aAAA,EACA,wBAAA,EACA,YAAA,mDAaA,SAAA,OAAA,iBACA,UAAA,aAAA,WAEA,GAAA,GAAA,CACA,QACA,SAAA,mKAKA,SAAA,KACA,SAAA,EACA,QAAA,WACA,OACA,eAAA,KAGA,KAAA,SAAA,EAAA,EAAA,EAAA,GAoIA,QAAA,KACA,EAAA,OACA,EAAA,KAAA,KACA,EAAA,WAAA,WACA,EAAA,MAAA,WACA,KACA,EAAA,KAAA,GAEA,EAAA,YAAA,mBAAA,EAAA,EACA,IAAA,GAAA,GACA,GAAA,OACA,EAAA,QAEA,EAAA,GAAA,OAAA,WACA,EAAA,YAAA,mBAAA,EAAA,GACA,EAAA,KAAA,KACA,IAAA,OACA,EAAA,aApJA,GAAA,GAAA,WACA,EAAA,cAAA,IAAA,QACA,EAAA,MAAA,SACA,EAAA,UAGA,EAAA,WACA,MAAA,GAAA,YAAA,KAAA,EAAA,WACA,EAAA,WAAA,mCAAA,EAAA,YAAA,WAEA,EAAA,YAAA,IACA,EAAA,WACA,MAAA,GAAA,KAAA,uBAEA,KAAA,KAAA,KAAA,EAEA,IAAA,GACA,EAAA,WAIA,MAHA,KACA,EAAA,EAAA,IAAA,IAEA,GAEA,EAAA,QAAA,UAAA,EAAA,EAAA,gBAwCA,EAAA,SAAA,GACA,EAAA,GAAA,OAAA,WACA,EAAA,YAGA,EAAA,GAAA,cAAA,WACA,EAAA,OACA,MAGA,EAAA,GAAA,QAAA,WACA,EAAA,OACA,MAGA,EAAA,GAAA,aAAA,SAAA,GACA,EAAA,UACA,EAAA,OACA,OAGA,EAAA,GAAA,OAAA,WACA,IAAA,SAwCA,GAAA,MAAA,EACA,EAAA,MAAA,EACA,EAAA,KAAA,OAEA,IAAA,GAAA,EAAA,KAAA,4BACA,GAAA,OAwBA,EAAA,YACA,KAGA,EAAA,KAAA,GACA,EAAA,YAAA,mBAAA,EAAA,IAIA,EAAA,QAAA,WACA,EAAA,KAAA,IACA,IAAA,GAAA,GACA,IACA,EAAA,WAAA,EAAA,YAAA,KAIA,EAAA,IAAA,WAAA,WACA,IACA,EAAA,UACA,EAAA,cAMA,OAAA","file":"ev-fdm-tinymce.min.js","sourcesContent":["/**\n * Directive to override some settings in tinymce\n * Usage:\n * <ev-tinymce\n *     max-chars=\"1000\"                        -- maxChars this input accept (default: unlimited)\n *     ng-model=\"message.body\"                 -- ng-model\n *     tinymce-options=\"tinymceOptions\"        -- override default options with yours (object expected)\n *  ></ev-tinymce>\n */\n(function (tinyMCE) {\n    var defaultOptions = {\n        menubar: false,\n        statusbar: false,\n        resize: false,\n        toolbar: 'bold italic underline | alignleft aligncenter alignright | bullist',\n        skin: false,\n        'verify_html': true,\n        'convert_fonts_to_spans': true,\n        'content_css': '/bower_components/ev-fdm/dist/css/ev-fdm.min.css',\n\n        // We choose to have a restrictive approach here.\n        // The aim is to output the cleanest html possible.\n        // See http://www.tinymce.com/wiki.php/Configuration:valid_elements\n        // 'valid_elements':\n        //     'strong,em' +\n        //     'span[!style<text-decoration: underline;],' +\n        //     '@[style<text-align: right;?text-align: left;?text-align: center;],' +\n        //     'p,!div,ul,li'\n    };\n\n\nangular.module('ev-tinymce', [])\n    .directive('evTinymce', [function () {\n\n        var generatedIds = 0;\n        return {\n            template: '<div class=\"tiny-mce-wrapper\">'\n                + '<div class=\"ev-placeholder-container\"></div>'\n                + '<div class=\"ev-tinymce-content\"></div>'\n                + '<span class=\"max-chars-info\">&nbsp;</span>'\n                + '</div>',\n            restrict: 'AE',\n            replace: true,\n            require: '?ngModel',\n            scope: {\n                tinymceOptions: '=',\n            },\n\n            link: function (scope, elm, attrs, ngModel) {\n                var updateView = function () {\n                    ngModel.$setViewValue(getTinyElm().html());\n                    if (!scope.$root.$$phase) {\n                      scope.$apply();\n                    }\n                };\n                var placeholderOrText = function () {\n                    return (ngModel.$viewValue && ngModel.$viewValue !== '') ?\n                        ngModel.$viewValue : '<span class=\"placeholder-light\">'+ attrs.placeholder +'</span>';\n                };\n                var tinyId = 'uiTinymce' + generatedIds++;\n                var getTinyElm = function() {\n                    return elm.find(\".ev-tinymce-content\");\n                };\n                getTinyElm().attr('id', tinyId);\n\n                var tinyInstance;\n                var getTinyInstance = function() {\n                    if (!tinyInstance) {\n                        tinyInstance = tinyMCE.get(tinyId);\n                    }\n                    return tinyInstance;\n                };\n                var options = angular.extend({}, defaultOptions, scope.tinymceOptions);\n\n\n                // /**\n                //  * This part is used for the max-chars attibute.\n                //  * It allows us to easily limit the number of characters typed in the editor\n                //  */\n                // options.maxChars = attrs.maxChars || options.maxChars || null;\n                // // We set the max char warning when the THRESHOLD is reached\n                // // Here, it's 85% of max chars\n                // var THRESHOLD = 85;\n\n                // /**\n                //  * Update the information area about the textEditor state (maxChars, ..)\n                //  */\n                // var updateInfo = function(currentChars, maxChars) {\n                //     var maxCharInfosElm = elm.parent().find('.max-chars-info');\n                //     maxCharInfosElm.text(currentChars + ' / ' + maxChars);\n\n                //     var isThresholdReached = ((currentChars / maxChars) * 100) > THRESHOLD;\n                //     var isMaxLimitReached  = currentChars >= maxChars;\n\n                //     var warningClassName = 'max-chars-warning';\n                //     var alertClassName   = 'max-chars-reached';\n                //     if(isThresholdReached) {\n                //         maxCharInfosElm.addClass(warningClassName);\n                //     } else {\n                //         maxCharInfosElm.removeClass(warningClassName);\n                //     }\n\n                //     if(isMaxLimitReached) {\n                //             maxCharInfosElm.addClass(alertClassName);\n                //     } else {\n                //             maxCharInfosElm.removeClass(alertClassName);\n                //     }\n                // };\n\n\n                /* Options */\n\n                var setup = function (ed) {\n                    ed.on('init', function() {\n                        ngModel.$render();\n                    });\n                    // Update model on button click\n                    ed.on('ExecCommand', function (e) {\n                        ed.save();\n                        updateView();\n                    });\n                    // Update model on keypress\n                    ed.on('KeyUp', function (e) {\n                        ed.save();\n                        updateView();\n                    });\n                    // Update model on change, i.e. copy/pasted text, plugins altering content\n                    ed.on('SetContent', function (e) {\n                        if(!e.initial){\n                            ed.save();\n                            updateView();\n                        }\n                    });\n                    ed.on('blur', function(e) {\n                        getTinyElm().blur();\n                    });\n\n                    // TODO : refactor with new changes\n                    // if(options.maxChars) {\n                    //     var currentText       = '';\n                    //     var currentTextLength = '';\n                    //     var oldText           = '';\n                    //     var maxChars          = options.maxChars;\n\n                    //     ed.on('init', function(e) {\n                    //        scope.$watch(function() { return ed.getContent(); }, function(newHtml, oldHtml) {\n                    //             currentText       = angular.element(newHtml).text();\n                    //             currentTextLength = currentText.length;\n                    //             oldText           = angular.element(oldHtml).text();\n\n                    //             *\n                    //              * Specific case where the old and new text are both over the limit of max chars.\n                    //              * This case can occur on the first initilization, if data from DB are over the \n                    //              * limit.\n                    //              * For now, we substring the content (but that break the html and everything..)\n                                 \n                    //             var isLimitAlert = (oldText.length > maxChars) && (currentTextLength > maxChars);\n                    //             if(isLimitAlert) {\n                    //                 var shorterText = oldText.substring(0, maxChars);\n                    //                 scope.ngModel = shorterText;\n                    //                 currentTextLength = shorterText.length;\n\n                    //             } else if(currentTextLength > maxChars) {\n                    //                 scope.ngModel    = oldHtml;\n                    //                 currentTextLength = angular.element(scope.ngModel).text().length;\n                    //             }\n\n                    //             updateInfo(currentTextLength, maxChars);\n                    //         });\n                    //     });\n                    // }\n                };\n\n                // extend options with initial uiTinymceConfig and options from directive attribute value\n                options.setup = setup;\n                options.elems = tinyId;\n                options.mode = \"exact\";\n\n                var placeholderElem = elm.find(\".ev-placeholder-container\");\n                placeholderElem.hide();\n                function setupPlaceholderBehaviour() {\n                    placeholderElem.show();\n                    placeholderElem.html(placeholderOrText());\n                    scope.$evalAsync(function () {\n                        placeholderElem.click(function () {\n                            if(!getTinyInstance()) {\n                                tinyMCE.init(options);\n                            }\n                            tinyMCE.execCommand(\"mceToggleEditor\", false, tinyId);\n                            var editor = getTinyInstance();\n                            placeholderElem.hide();\n                            editor.focus();\n\n                            editor.on('blur', function (e) {\n                                tinyMCE.execCommand(\"mceToggleEditor\", false, tinyId);\n                                placeholderElem.html(placeholderOrText());\n                                getTinyElm().hide();\n                                placeholderElem.show();\n                            });\n                        });\n                    });\n                }\n\n                if (attrs.placeholder) {\n                    setupPlaceholderBehaviour();\n                } else {\n                    // setTimeout(function () {\n                        tinyMCE.init(options);\n                        tinyMCE.execCommand(\"mceToggleEditor\", false, tinyId);\n                    // }, 1000);\n                }\n\n                ngModel.$render = function() {\n                    placeholderElem.html(placeholderOrText());\n                    var editor = getTinyInstance();\n                    if (editor) {\n                        editor.setContent(ngModel.$viewValue || '');\n                    }\n                };\n\n                scope.$on('$destroy', function() {\n                    if (tinyInstance) {\n                        tinyInstance.destroy();\n                        tinyInstance = null;\n                    }\n                });\n            },\n        };\n    }]);\n}) (window.tinyMCE);\n"],"sourceRoot":"/source/"}