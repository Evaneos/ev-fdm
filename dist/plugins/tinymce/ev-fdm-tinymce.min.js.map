{"version":3,"sources":["plugins/evelements.js","plugins/evimage.js","directives/tinymceDirective.js"],"names":["tinymce","PluginManager","add","editor","setElement","elementConfig","dom","node","selection","getNode","matches","remove","insertContent","createHTML","name","encode","getContent","format","showDialog","attributes","attribs","getAttribs","i","length","item","value","key","callback","evelementsOptions","text","innerText","textContent","newAttributes","focus","undoManager","removeAllAttribs","setAttribs","select","setContent","evelementsConfig","settings","evelements","split","forEach","nodeName","toLowerCase","callbackAction","addButton","undefined","title","icon","tooltip","shortcut","onclick","stateSelector","selector","addShortcut","getAttribute","src","getAttrib","alt","class","data-picture-id","evimage","attributesNew","console","log","addMenuItem","context","prependToContext","addCommand","tinyMCE","countWords","wordArray","match","countregexp","defaultOptions","menubar","statusbar","toolbar","skin","verify_html","convert_fonts_to_spans","inline","browser_spellcheck","angular","module","provider","configs","this","register","hasOwnProperty","Error","get","$get","directive","$timeout","evTinymce","generatedIds","template","restrict","replace","require","scope","tinymceOptions","link","elm","attrs","ngModel","tinyId","tinyElm","find","attr","tinyInstance","getTinyInstance","options","extend","fixed_toolbar_container","configKey","minChars","maxChars","minWords","maxWords","THRESHOLD","updateCounter","currentValue","minValue","maxValue","counterInfosElm","parent","isThresholdReached","toggleClass","isMinLimitNotReached","isMaxLimitReached","hasFocus","placeholder","currentHtml","currentText","setPlaceholder","DOM","addClass","updatePlaceholder","newText","setCursorLocation","removeClass","updateView","newCount","minCount","maxCount","newHtml","html","newTextOverLimit","currentTextOverLimit","$setViewValue","shorterText","substr","$render","$viewValue","focusTinymce","setup","on","e","initial","blur","elems","mode","init","$on","destroy","execCommand","window"],"mappings":"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","file":"ev-fdm-tinymce.min.js","sourcesContent":["/* global tinymce */\n\ntinymce.PluginManager.add('evelements', function(editor) {\n    var evelementsConfig = editor.settings.evelements;\n    var evelementsOptions = editor.settings.evelementsOptions;\n\n    function setElement(elementConfig) {\n        return function() {\n            var dom = editor.dom;\n            var node = editor.selection.getNode();\n            if (node && elementConfig.matches(node)) {\n                dom.remove(node, true);\n            } else {\n                editor.insertContent(\n                    dom.createHTML(\n                        elementConfig.name,\n                        {},\n                        dom.encode(editor.selection.getContent({ format: 'text' }))\n                    )\n                );\n            }\n        };\n    }\n\n    function showDialog(elementConfig) {\n        return function() {\n            var dom = editor.dom;\n            var node = editor.selection.getNode();\n            var attributes = null;\n\n            if (node && elementConfig.matches(node)) {\n                attributes = {};\n                var attribs = dom.getAttribs(node);\n                for (var i = 0; i < attribs.length; ++i) {\n                    var item = attribs[i];\n                    attributes[item.name] = item.value;\n                }\n            } else {\n                node = null;\n            }\n\n            var key = elementConfig.key || elementConfig.name;\n            var callback = evelementsOptions[key] && evelementsOptions[key].callback;\n            var text = node ? ('innerText' in node ? node.innerText : node.textContent)\n                                 : editor.selection.getContent({ format: 'text' });\n            (callback || elementConfig.callback)(attributes, function(newAttributes, text) {\n                if (node) {\n                    editor.focus();\n                    if (!newAttributes && !text) {\n                        dom.remove(node, true);\n                        editor.undoManager.add();\n                        return;\n                    }\n                    dom.removeAllAttribs(node);\n                    dom.setAttribs(node, newAttributes);\n                    if (text) {\n                        if ('innerText' in node) {\n                            node.innerText = text;\n                        } else {\n                            node.textContent = text;\n                        }\n                    }\n                    editor.selection.select(node);\n                    editor.undoManager.add();\n                } else {\n                    editor.focus();\n                    node = dom.createHTML(elementConfig.name, newAttributes, text && dom.encode(text));\n                    editor.selection.setContent(node);\n                    editor.undoManager.add();\n                }\n            }, text, evelementsOptions);\n        };\n    }\n\n    if (typeof evelementsConfig === 'string') {\n        evelementsConfig = evelementsConfig.split(' ');\n    }\n\n    evelementsConfig.forEach(function(elementConfig) {\n        if (typeof elementConfig === 'string') {\n            elementConfig = {\n                name: elementConfig\n            };\n        }\n\n        elementConfig.matches = elementConfig.matches || function(node) {\n            return node.nodeName.toLowerCase() === elementConfig.name;\n        };\n\n        var callbackAction = elementConfig.callback ? showDialog(elementConfig) : setElement(elementConfig);\n\n        editor.addButton('ev' + (elementConfig.key || elementConfig.name), {\n            text: elementConfig.title !== undefined ? elementConfig.title : elementConfig.name,\n            icon: elementConfig.icon,\n            tooltip: elementConfig.tooltip || ('Set this text as ' + elementConfig.name),\n            shortcut: elementConfig.shortcut,\n            onclick: callbackAction,\n            stateSelector: elementConfig.selector || elementConfig.name,\n        });\n\n        if (elementConfig.shortcut) {\n            editor.addShortcut(elementConfig.shortcut, '', callbackAction);\n        }\n    });\n});\n","/* global tinymce, console */\n\ntinymce.PluginManager.add('evimage', function(editor) {\n    console.log('evimage is deprecated: use evelements');\n    function showDialog() {\n        var dom = editor.dom;\n        var node = editor.selection.getNode();\n        var attributes = null;\n\n        if (node && node.getAttribute('data-picture-id')) {\n            attributes = {\n                src: dom.getAttrib(node, 'src'),\n                alt: dom.getAttrib(node, 'alt'),\n                'class': dom.getAttrib(node, 'class'),\n                'data-picture-id': dom.getAttrib(node, 'data-picture-id')\n            };\n        }\n\n        editor.settings.evimage(attributes, function(attributesNew) {\n            if (attributes) {\n                dom.removeAllAttribs(node);\n                dom.setAttribs(node, attributesNew);\n            } else {\n                editor.selection.setContent(editor.dom.createHTML('img', attributesNew));\n            }\n        });\n    }\n\n    editor.addButton('evimage', {\n        icon: 'image',\n        tooltip: 'Insert/edit image',\n        onclick: showDialog,\n        stateSelector: 'img[data-picture-id]:not([data-mce-object],[data-mce-placeholder])'\n    });\n\n    editor.addMenuItem('evimage', {\n        icon: 'image',\n        text: 'Insert image',\n        onclick: showDialog,\n        context: 'insert',\n        prependToContext: true\n    });\n\n    editor.addCommand('mceImage', showDialog);\n});\n","/* jshint camelcase: false */\n/* global tinymce */\n/**\n * Directive to override some settings in tinymce\n * Usage:\n * <ev-tinymce\n *     min-chars=\"1000\"                        -- minChars this input accept (default: none)\n *     max-chars=\"1000\"                        -- maxChars this input accept (default: unlimited)\n *     min-words=\"1000\"                        -- minWords this input accept (default: none)\n *     max-words=\"1000\"                        -- maxWords this input accept (default: unlimited)\n *     ng-model=\"message.body\"                 -- ng-model\n *     tinymce-options=\"tinymceOptions\"        -- override default options with yours (object expected)\n *  ></ev-tinymce>\n */\n(function (tinyMCE) {\n    var defaultOptions = {\n        menubar: false,\n        statusbar: false,\n        //resize: false,\n        toolbar: 'bold italic underline | alignleft aligncenter alignright | bullist',\n        skin: false,\n        'verify_html': true,\n        'convert_fonts_to_spans': true,\n        //'content_css': '/bower_components/ev-fdm/dist/css/ev-fdm.min.css',\n        inline: true,\n        browser_spellcheck : true,\n\n        // We choose to have a restrictive approach here.\n        // The aim is to output the cleanest html possible.\n        // See http://www.tinymce.com/wiki.php/Configuration:valid_elements\n        // 'valid_elements':\n        //     'strong,em' +\n        //     'span[!style<text-decoration: underline;],' +\n        //     '@[style<text-align: right;?text-align: left;?text-align: center;],' +\n        //     'p,!div,ul,li'\n    };\n\n    // u2019 and x27 : apostrophes\n    // u00C0-\\u1FFF : accents\n    var countregexp = /[\\w\\u2019\\x27\\-\\u00C0-\\u1FFF]+/g;\n    function countWords(text) {\n        var wordArray = text.match(countregexp);\n        if (wordArray) {\n            return wordArray.length;\n        }\n        return 0;\n    }\n\n\nangular.module('ev-tinymce', [])\n    .provider('evTinymce', function() {\n        var configs = {};\n\n        this.register = function(name, value) {\n            if (configs.hasOwnProperty(name)) {\n                throw new Error('A config named \"' + name + '\" was already registered');\n            }\n            configs[name] = value;\n        };\n\n        this.get = function(name) {\n            return configs[name];\n        };\n\n        this.$get = function() { return configs; };\n    })\n    .directive('evTinymce', ['$timeout', 'evTinymce', function($timeout, evTinymce) {\n        var generatedIds = 0;\n        return {\n            template: '<div class=\"tiny-mce-wrapper form-control\">'\n                + '<div class=\"ev-placeholder-container\"></div>'\n                + '<div class=\"ev-tinymce-content\"></div>'\n                + '<div ng-click=\"focusTinymce()\" class=\"ev-tinymce-toolbar\"></div>'\n                + '<div class=\"counter-info\"></div>'\n                + '</div>',\n            restrict: 'AE',\n            replace: true,\n            require: '?ngModel',\n\n            scope: {\n                tinymceOptions: '=',\n            },\n\n            link: function (scope, elm, attrs, ngModel) {\n                var tinyId = 'uiTinymce' + generatedIds++;\n                var tinyElm = elm.find('.ev-tinymce-content');\n                tinyElm.attr('id', tinyId);\n                elm.find('.ev-tinymce-toolbar').attr('id', tinyId + 'toolbar');\n\n                var tinyInstance;\n                var getTinyInstance = function() {\n                    if (!tinyInstance) {\n                        tinyInstance = tinyMCE.get(tinyId);\n                    }\n                    return tinyInstance;\n                };\n                var options = angular.extend({\n                    fixed_toolbar_container: '#' + tinyId + 'toolbar',\n                }, defaultOptions, evTinymce[attrs.configKey], scope.tinymceOptions);\n\n                // /**\n                //  * This part is used for the max-chars attribute.\n                //  * It allows us to easily limit the number of characters typed in the editor\n                //  */\n                var minChars = options.minChars = attrs.minChars || options.minChars || null;\n                var maxChars = options.maxChars = attrs.maxChars || options.maxChars || null;\n                var minWords = options.minWords = attrs.minWords || options.minWords || null;\n                var maxWords = options.maxWords = attrs.maxWords || options.maxWords || null;\n                // // We set the max char warning when the THRESHOLD is reached\n                // // Here, it's 85% of max chars\n                var THRESHOLD = 85;\n\n                // /**\n                //  * Update the information area about the textEditor state (maxChars, ..)\n                //  */\n                var updateCounter = function(currentValue, minValue, maxValue) {\n                    var counterInfosElm = elm.parent().find('.counter-info');\n                    counterInfosElm.text(currentValue + (maxValue ? ' / ' + maxValue : ''));\n\n                    if (maxValue) {\n                        var isThresholdReached = ((currentValue / maxValue) * 100) > THRESHOLD;\n                        counterInfosElm.toggleClass('counter-warning', isThresholdReached);\n                    }\n\n                    var isMinLimitNotReached = minValue && currentValue < minValue;\n                    var isMaxLimitReached = maxValue && currentValue >= maxValue;\n                    counterInfosElm.toggleClass('counter-reached', !!(isMinLimitNotReached || isMaxLimitReached));\n                };\n\n                var hasFocus = false;\n                var placeholder = false;\n                var currentHtml = '';\n                var currentText = '';\n\n                var setPlaceholder = function() {\n                    var editor = getTinyInstance();\n                    tinymce.DOM.addClass(tinyElm, 'placeholder-light');\n                    editor.setContent(attrs.placeholder);\n                };\n\n                var updatePlaceholder = function(newText) {\n                    var editor = getTinyInstance();\n                    if (hasFocus) {\n                        if (currentText === attrs.placeholder) {\n                            editor.setContent('');\n                            editor.selection.setCursorLocation();\n                            tinymce.DOM.removeClass(tinyElm, 'placeholder-light');\n                        }\n                    } else {\n                        if (newText !== attrs.placeholder) {\n                            setPlaceholder();\n                        }\n                    }\n                };\n\n                var updateView = function () {\n                    var editor = getTinyInstance();\n                    var newHtml = tinyElm.html();\n                    var newText = tinyElm.text();\n                    var newTextOverLimit = false, currentTextOverLimit = false;\n                    var newCount, minCount, maxCount;\n\n                    if (placeholder && newText === attrs.placeholder) {\n                        currentHtml = newHtml;\n                        currentText = newText;\n                        if (maxChars || minChars || maxWords || minWords) {\n                            newCount = 0;\n                        }\n                    } else {\n                        if (maxChars || minChars) {\n                            newCount = newText.length;\n                        } else if (maxWords || minWords) {\n                            newCount = countWords(newText);\n                        }\n\n                        if (minChars) {\n                            minCount = minChars;\n                        } else if (minWords) {\n                            minCount = minWords;\n                        }\n\n                        if (maxChars) {\n                            maxCount = maxChars;\n                            newTextOverLimit = newCount > maxChars;\n                        } else if (maxWords) {\n                            maxCount = maxWords;\n                            newTextOverLimit = newCount > maxWords;\n                        }\n\n                        /*\n                         * Specific case where the old and new text are both over the limit of max chars.\n                         * This case can occur on the first initialization, if data from DB are over the\n                         * limit.\n                         * For now, we substring the content (but that break the html and everything..)\n                         */\n                        if (newTextOverLimit && (currentTextOverLimit || !currentText.length)) {\n                            var shorterText = newText.substr(0, maxChars);\n                            // be careful, setContent call this method again\n                            editor.setContent(shorterText, { format: 'text' });\n                        } else if (newTextOverLimit) {\n                            editor.setContent(currentHtml); // be careful, setContent call this method again\n                        } else {\n                            $timeout(function() {\n                                ngModel.$setViewValue(newText === '' || newText === attrs.placeholder ? '' : newHtml);\n                            });\n                            currentHtml = newHtml;\n                            currentText = newText;\n                        }\n                    }\n\n                    // newCount not null nor undefined\n                    if (newCount != null) {\n                        updateCounter(newCount, minCount, maxCount);\n                    }\n\n\n                    placeholder = newText === '' || newText === attrs.placeholder;\n\n                    if (placeholder && attrs.placeholder) {\n                        updatePlaceholder(newText);\n                    }\n                };\n\n                ngModel.$render = function() {\n                    var editor = getTinyInstance();\n                    if (editor) {\n                        if (ngModel.$viewValue) {\n                            editor.setContent(ngModel.$viewValue);\n                        } else if (attrs.placeholder) {\n                            placeholder = true;\n                            setPlaceholder();\n                        }\n                    }\n                };\n\n                scope.focusTinymce = function() {\n                    var editor = getTinyInstance();\n                    if (editor) {\n                        editor.focus();\n                    }\n                };\n\n                /* Options */\n\n                var setup = function(editor) {\n                    editor.on('init', function() {\n                        if (ngModel.$viewValue) {\n                            ngModel.$render();\n                        }\n                    });\n                    // Update model on button click\n                    editor.on('ExecCommand', function (e) {\n                        updateView();\n                    });\n                    // Update model on keypress\n                    editor.on('KeyUp', function (e) {\n                        updateView();\n                    });\n                    // Update model on change, i.e. copy/pasted text, plugins altering content\n                    editor.on('SetContent', function (e) {\n                        if (!e.initial) {\n                            updateView();\n                        }\n                    });\n                    editor.on('blur', function(e) {\n                        if (hasFocus) {\n                            hasFocus = false;\n                            updateView();\n                        }\n                        tinyElm.blur();\n                    });\n\n                    editor.on('focus', function (e) {\n                        if (!hasFocus) {\n                            hasFocus = true;\n                            updateView();\n                        }\n                    });\n                };\n\n                // extend options with initial uiTinymceConfig and options from directive attribute value\n                options.setup = setup;\n                options.elems = tinyId;\n                options.mode = 'exact';\n\n                tinyMCE.init(options);\n\n                scope.$on('$destroy', function() {\n                    var editor = getTinyInstance();\n                    if (editor) {\n                        editor.destroy();\n                    }\n                });\n\n                tinyMCE.execCommand('mceToggleEditor', false, tinyId);\n            },\n        };\n    }]);\n}) (window.tinyMCE);\n"],"sourceRoot":"/source/"}